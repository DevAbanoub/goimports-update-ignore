// Copyright 2016 Peter Waller <p@pwaller.net>. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

// Test program which references a non-existent package. This forces goimports
// to do the maximal amount of work to determine it doesn't exist.
const fakePkg = "package main\nvar _ = thisPackageDoesNotExist328955Z828592.X()"

// Generated lines will be placed between genStart and genEnd lines.
const (
	genStart = "# Generated by goimports-update-ignore"
	genEnd   = "# END-AUTO-GENERATED BY goimports-update-ignore"
)

type ø struct{} // Alt-Gr + O

func main() {
	var (
		maxDepth    = flag.Int("max-depth", 3, "maximum depth of ignore rules to produce")
		measureOnly = flag.Bool("measure-only", false, "do not generate ignore rules, only measure goimports")
	)

	flag.Parse()

	if *maxDepth < 1 {
		log.Fatal("invalid maxDepth, must be >= 1")
	}

	goPath := filepath.Join(os.Getenv("GOPATH"), "src")

	if *measureOnly {
		showStats(readIgnored(goPath))
		return
	}

	hasGo, err := getGoDirectories(goPath, *maxDepth)
	if err != nil {
		log.Fatal(err)
	}

	nIgnored, err := writeGoImportsIgnore(goPath, *maxDepth, hasGo)
	if err != nil {
		log.Fatal(err)
	}

	showStats(nIgnored)
}

func readIgnored(path string) int {
	var ignored int
	slurp, err := ioutil.ReadFile(filepath.Join(path, ".goimportsignore"))
	if err != nil {
		return 0
	}
	bs := bufio.NewScanner(bytes.NewReader(slurp))
	for bs.Scan() {
		line := strings.TrimSpace(bs.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		if _, err := os.Stat(filepath.Join(path, line)); err == nil {
			ignored++
		}
	}
	return ignored
}

func showStats(nIgnored int) {
	nScanned, wallTime, uTime, err := countGoImportsScanned()
	if err != nil {
		log.Printf("countGoImportsScanned warning: %v", err)
	}

	log.Printf("Ignored %d directories. goimports considers %d directories in %.0fms (cpu=%0.fms).",
		nIgnored, nScanned, wallTime.Seconds()*1000, uTime.Seconds()*1000)
}

// countGoImportsScanned runs goimports and looks out the verbose log output to
// determine the number of directories scanned. A separate non-verbose run is
// done to measure the run time.
func countGoImportsScanned() (int, time.Duration, time.Duration, error) {
	cmd := exec.Command("goimports", "-v")
	cmd.Stdin = strings.NewReader(fakePkg)

	stderr, err := cmd.StderrPipe()
	if err != nil {
		return 0, 0, 0, err
	}

	err = cmd.Start()
	if err != nil {
		return 0, 0, 0, err
	}

	nScans, err := countScans(stderr)
	if err != nil {
		return 0, 0, 0, err
	}

	err = cmd.Wait()
	if err != nil {
		return 0, 0, 0, err
	}

	// Separate timing run without verbose output which slows things down.
	start := time.Now()
	cmd = exec.Command("goimports")
	cmd.Stdin = strings.NewReader(fakePkg)
	err = cmd.Run()

	return nScans, time.Since(start), cmd.ProcessState.UserTime(), err
}

func countScans(r io.Reader) (int, error) {
	var n int
	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		if !bytes.Contains(scanner.Bytes(), []byte("scanning dir")) {
			continue
		}
		n++
	}
	return n, scanner.Err()
}

func getGoDirectories(goPath string, maxDepth int) (func(string) bool, error) {

	// goDirectories will contain all directories at `depth` or less
	// which have .go files.
	goDirectories := map[string]ø{}
	hasGo := func(p string) bool {
		_, ok := goDirectories[p]
		return ok
	}

	err := filepath.Walk(goPath, func(path string, fi os.FileInfo, err error) error {
		if err != nil {
			if os.IsPermission(err) {
				log.Printf("permission denied: %s", path)
				return nil
			}
			return err
		}
		path, err = filepath.Rel(goPath, path)
		if err != nil {
			return err
		}
		if !strings.HasSuffix(path, ".go") {
			return err
		}

		path = filepath.ToSlash(path)
		parts := strings.Split(path, "/")
		for i := 0; i < maxDepth && i+1 < len(parts); i++ {
			goDirectories[filepath.Join(parts[:i+1]...)] = ø{}
		}
		return err
	})

	return hasGo, err
}

func writeGoImportsIgnore(
	goPath string, maxDepth int, hasGo func(string) bool,
) (int, error) {
	filename := filepath.Join(goPath, ".goimportsignore")
	// Save lines except genereated lines.
	saved := manuallyEditedLines(filename)
	fd, err := os.Create(filename)
	if err != nil {
		return 0, err
	}
	defer fd.Close()
	// Restore lines first.
	fd.Write(saved)

	_, _ = fmt.Fprintf(fd, "%s %v\n", genStart, time.Now().UTC())

	var ignored int

	err = filepath.Walk(goPath, func(path string, fi os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		path, err = filepath.Rel(goPath, path)
		if err != nil {
			return err
		}
		if path == "." {
			// Ignore goPath itself.
			return nil
		}

		path = filepath.ToSlash(path)
		curDepth := strings.Count(path, "/") + 1

		switch {
		case !fi.IsDir():
			// Only directories are ignored, not files.
			return nil
		case strings.HasPrefix(filepath.Base(path), "."):
			// .git, etc. Ignored by goimports anyway.
			return filepath.SkipDir
		case !hasGo(path):
			// These are paths which should be ignored
			fmt.Fprintln(fd, path)
			ignored++
			// It's ignored so we don't need t olook inside.
			return filepath.SkipDir
		case curDepth >= maxDepth:
			// These are too deep to explicitly ignore.
			return filepath.SkipDir
		}
		return nil
	})
	_, _ = fmt.Fprintln(fd, genEnd)

	return ignored, err
}

// manuallyEditedLines returns manually edited lines in ignoreFile.
func manuallyEditedLines(ignoreFile string) []byte {
	f, err := os.Open(ignoreFile)
	if err != nil {
		return nil
	}
	defer f.Close()
	var buf bytes.Buffer
	s := bufio.NewScanner(f)
	inGenSection := false
	for s.Scan() {
		l := s.Text()
		switch {
		case strings.HasPrefix(l, genStart):
			inGenSection = true
		case strings.HasPrefix(l, genEnd):
			inGenSection = false
		case !inGenSection:
			buf.WriteString(l)
			buf.WriteRune('\n')
		}
	}
	return buf.Bytes()
}
